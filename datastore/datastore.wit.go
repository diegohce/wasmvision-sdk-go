// Code generated by wit-bindgen-go. DO NOT EDIT.

// Package datastore represents the imported interface "wasmvision:platform/datastore".
package datastore

import (
	"go.bytecodealliance.org/cm"
)

// DatastoreError represents the enum "wasmvision:platform/datastore#datastore-error".
//
// datastore errors returned by the runtime.
//
//	enum datastore-error {
//		success,
//		no-such-store,
//		runtime-error
//	}
type DatastoreError uint8

const (
	DatastoreErrorSuccess DatastoreError = iota
	DatastoreErrorNoSuchStore
	DatastoreErrorRuntimeError
)

var stringsDatastoreError = [3]string{
	"success",
	"no-such-store",
	"runtime-error",
}

// String implements [fmt.Stringer], returning the enum case name of e.
func (e DatastoreError) String() string {
	return stringsDatastoreError[e]
}

// FrameStore represents the imported resource "wasmvision:platform/datastore#frame-store".
//
// frame-store is the interface for storing data associated with a specific frame.
//
//	resource frame-store
type FrameStore cm.Resource

// ResourceDrop represents the imported resource-drop for resource "frame-store".
//
// Drops a resource handle.
//
//go:nosplit
func (self FrameStore) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_FrameStoreResourceDrop((uint32)(self0))
	return
}

// NewFrameStore represents the imported constructor for resource "frame-store".
//
// The id param is currently ignored
//
//	constructor(id: u32)
//
//go:nosplit
func NewFrameStore(id uint32) (result FrameStore) {
	id0 := (uint32)(id)
	result0 := wasmimport_NewFrameStore((uint32)(id0))
	result = cm.Reinterpret[FrameStore]((uint32)(result0))
	return
}

// Delete represents the imported method "delete".
//
// Delete the tuple with the specified `key`
//
// No error is raised if a tuple did not previously exist for `key`.
//
//	delete: func(frame: u32, key: string) -> result<_, datastore-error>
//
//go:nosplit
func (self FrameStore) Delete(frame uint32, key string) (result cm.Result[DatastoreError, struct{}, DatastoreError]) {
	self0 := cm.Reinterpret[uint32](self)
	frame0 := (uint32)(frame)
	key0, key1 := cm.LowerString(key)
	wasmimport_FrameStoreDelete((uint32)(self0), (uint32)(frame0), (*uint8)(key0), (uint32)(key1), &result)
	return
}

// Exists represents the imported method "exists".
//
// Return whether a tuple exists for the specified `key`
//
//	exists: func(frame: u32, key: string) -> result<bool, datastore-error>
//
//go:nosplit
func (self FrameStore) Exists(frame uint32, key string) (result cm.Result[bool, bool, DatastoreError]) {
	self0 := cm.Reinterpret[uint32](self)
	frame0 := (uint32)(frame)
	key0, key1 := cm.LowerString(key)
	wasmimport_FrameStoreExists((uint32)(self0), (uint32)(frame0), (*uint8)(key0), (uint32)(key1), &result)
	return
}

// Get represents the imported method "get".
//
// Get the value associated with the specified `key`
//
// Returns `ok(none)` if the key does not exist.
//
//	get: func(frame: u32, key: string) -> result<list<u8>, datastore-error>
//
//go:nosplit
func (self FrameStore) Get(frame uint32, key string) (result cm.Result[cm.List[uint8], cm.List[uint8], DatastoreError]) {
	self0 := cm.Reinterpret[uint32](self)
	frame0 := (uint32)(frame)
	key0, key1 := cm.LowerString(key)
	wasmimport_FrameStoreGet((uint32)(self0), (uint32)(frame0), (*uint8)(key0), (uint32)(key1), &result)
	return
}

// GetKeys represents the imported method "get-keys".
//
// Return a list of all the keys
//
//	get-keys: func(frame: u32) -> result<list<string>, datastore-error>
//
//go:nosplit
func (self FrameStore) GetKeys(frame uint32) (result cm.Result[cm.List[string], cm.List[string], DatastoreError]) {
	self0 := cm.Reinterpret[uint32](self)
	frame0 := (uint32)(frame)
	wasmimport_FrameStoreGetKeys((uint32)(self0), (uint32)(frame0), &result)
	return
}

// Set represents the imported method "set".
//
// Set the `value` associated with the specified `key` overwriting any existing value.
//
//	set: func(frame: u32, key: string, value: list<u8>) -> result<_, datastore-error>
//
//go:nosplit
func (self FrameStore) Set(frame uint32, key string, value cm.List[uint8]) (result cm.Result[DatastoreError, struct{}, DatastoreError]) {
	self0 := cm.Reinterpret[uint32](self)
	frame0 := (uint32)(frame)
	key0, key1 := cm.LowerString(key)
	value0, value1 := cm.LowerList(value)
	wasmimport_FrameStoreSet((uint32)(self0), (uint32)(frame0), (*uint8)(key0), (uint32)(key1), (*uint8)(value0), (uint32)(value1), &result)
	return
}

// ProcessorStore represents the imported resource "wasmvision:platform/datastore#processor-store".
//
// processor-store is the interface for storing data associated with a processor.
//
//	resource processor-store
type ProcessorStore cm.Resource

// ResourceDrop represents the imported resource-drop for resource "processor-store".
//
// Drops a resource handle.
//
//go:nosplit
func (self ProcessorStore) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_ProcessorStoreResourceDrop((uint32)(self0))
	return
}

// NewProcessorStore represents the imported constructor for resource "processor-store".
//
// The id param is currently ignored
//
//	constructor(id: u32)
//
//go:nosplit
func NewProcessorStore(id uint32) (result ProcessorStore) {
	id0 := (uint32)(id)
	result0 := wasmimport_NewProcessorStore((uint32)(id0))
	result = cm.Reinterpret[ProcessorStore]((uint32)(result0))
	return
}

// Delete represents the imported method "delete".
//
// Delete the tuple with the specified `key`
//
// No error is raised if a tuple did not previously exist for `key`.
//
//	delete: func(processor: string, key: string) -> result<_, datastore-error>
//
//go:nosplit
func (self ProcessorStore) Delete(processor string, key string) (result cm.Result[DatastoreError, struct{}, DatastoreError]) {
	self0 := cm.Reinterpret[uint32](self)
	processor0, processor1 := cm.LowerString(processor)
	key0, key1 := cm.LowerString(key)
	wasmimport_ProcessorStoreDelete((uint32)(self0), (*uint8)(processor0), (uint32)(processor1), (*uint8)(key0), (uint32)(key1), &result)
	return
}

// Exists represents the imported method "exists".
//
// Return whether a tuple exists for the specified `key`
//
//	exists: func(processor: string, key: string) -> result<bool, datastore-error>
//
//go:nosplit
func (self ProcessorStore) Exists(processor string, key string) (result cm.Result[bool, bool, DatastoreError]) {
	self0 := cm.Reinterpret[uint32](self)
	processor0, processor1 := cm.LowerString(processor)
	key0, key1 := cm.LowerString(key)
	wasmimport_ProcessorStoreExists((uint32)(self0), (*uint8)(processor0), (uint32)(processor1), (*uint8)(key0), (uint32)(key1), &result)
	return
}

// Get represents the imported method "get".
//
// Get the value associated with the specified `key`
//
// Returns `ok(none)` if the key does not exist.
//
//	get: func(processor: string, key: string) -> result<list<u8>, datastore-error>
//
//go:nosplit
func (self ProcessorStore) Get(processor string, key string) (result cm.Result[cm.List[uint8], cm.List[uint8], DatastoreError]) {
	self0 := cm.Reinterpret[uint32](self)
	processor0, processor1 := cm.LowerString(processor)
	key0, key1 := cm.LowerString(key)
	wasmimport_ProcessorStoreGet((uint32)(self0), (*uint8)(processor0), (uint32)(processor1), (*uint8)(key0), (uint32)(key1), &result)
	return
}

// GetKeys represents the imported method "get-keys".
//
// Return a list of all the keys
//
//	get-keys: func(processor: string) -> result<list<string>, datastore-error>
//
//go:nosplit
func (self ProcessorStore) GetKeys(processor string) (result cm.Result[cm.List[string], cm.List[string], DatastoreError]) {
	self0 := cm.Reinterpret[uint32](self)
	processor0, processor1 := cm.LowerString(processor)
	wasmimport_ProcessorStoreGetKeys((uint32)(self0), (*uint8)(processor0), (uint32)(processor1), &result)
	return
}

// Set represents the imported method "set".
//
// Set the `value` associated with the specified `key` overwriting any existing value.
//
//	set: func(processor: string, key: string, value: list<u8>) -> result<_, datastore-error>
//
//go:nosplit
func (self ProcessorStore) Set(processor string, key string, value cm.List[uint8]) (result cm.Result[DatastoreError, struct{}, DatastoreError]) {
	self0 := cm.Reinterpret[uint32](self)
	processor0, processor1 := cm.LowerString(processor)
	key0, key1 := cm.LowerString(key)
	value0, value1 := cm.LowerList(value)
	wasmimport_ProcessorStoreSet((uint32)(self0), (*uint8)(processor0), (uint32)(processor1), (*uint8)(key0), (uint32)(key1), (*uint8)(value0), (uint32)(value1), &result)
	return
}
